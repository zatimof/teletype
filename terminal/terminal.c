#define FSIZE 10000 //(max 32768)

#include <stdio.h>
#include <conio.h>
#include <Windows.h>
#pragma hdrstop

unsigned char buffer[FSIZE], outbuffer[2*FSIZE], current_case = 0, current_case_r = 0, c, d;
unsigned int i, baseaddr = 0, filesize = 0, outbuff_point = 0;
HANDLE *pp, *fp;
DCB dcb;
COMMTIMEOUTS commtimeouts;

const unsigned char case_table[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x03, 0x00, 0x03,
0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02
};

const unsigned char code_table[256] = {
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE2, 0xE4, 0xE4, 0xE8, 0xE4, 0xE4,
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE5, 0xEF, 0xF2, 0xE4, 0xF1, 0xEC, 0xE3, 0xFC, 0xFD,
0xF6, 0xF7, 0xF3, 0xE1, 0xEA, 0xF0, 0xF5, 0xE7, 0xE6, 0xF8, 0xEE, 0xE4, 0xE4, 0xFE, 0xE4, 0xF9,
0xE9, 0xE3, 0xF9, 0xEE, 0xE9, 0xE1, 0xED, 0xFA, 0xF4, 0xE6, 0xEB, 0xEF, 0xF2, 0xFC, 0xEC, 0xF8,
0xF6, 0xF7, 0xEA, 0xE5, 0xF0, 0xE7, 0xFE, 0xF3, 0xFD, 0xF5, 0xF1, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE9, 0xE3, 0xF9, 0xEE, 0xE9, 0xE1, 0xED, 0xFA, 0xF4, 0xE6, 0xEB, 0xEF, 0xF2, 0xFC, 0xEC, 0xF8,
0xF6, 0xF7, 0xEA, 0xE5, 0xF0, 0xE7, 0xFE, 0xF3, 0xFD, 0xF5, 0xF1, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE1, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE1, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
0xE3, 0xF9, 0xF3, 0xFA, 0xE9, 0xE1, 0xFE, 0xF1, 0xE6, 0xEB, 0xEF, 0xF2, 0xFC, 0xEC, 0xF8, 0xF6,
0xEA, 0xE5, 0xF0, 0xE7, 0xED, 0xF4, 0xEE, 0xEA, 0xFA, 0xF4, 0xFD, 0xF5, 0xFD, 0xED, 0xEB, 0xF7,
0xE3, 0xF9, 0xF3, 0xFA, 0xE9, 0xE1, 0xFE, 0xF1, 0xE6, 0xEB, 0xEF, 0xF2, 0xFC, 0xEC, 0xF8, 0xF6,
0xEA, 0xE5, 0xF0, 0xE7, 0xED, 0xF4, 0xEE, 0xEA, 0xFA, 0xF4, 0xFD, 0xF5, 0xFD, 0xED, 0xEB, 0xF7
};

const unsigned char decode_table[3][32] = {
{' ', 'E', '\n', 'A', ' ', 'S', 'I', 'U', '\r', 'D', 'R', 'J', 'N', 'F', 'C', 'K',
 'T', 'Z', 'L', 'W', 'H', 'Y', 'P', 'Q', 'O', 'B', 'G', ' ', 'M', 'X', 'V', ' '},
{' ', 'Å', '\n', 'À', ' ', 'Ñ', 'È', 'Ó', '\r', 'Ä', 'Ð', 'É', 'Í', 'Ô', 'Ö', 'Ê',
 'Ò', 'Ç', 'Ë', 'Â', 'Õ', 'Û', 'Ï', 'ß', 'Î', 'Á', 'Ã', ' ', 'Ì', 'Ü', 'Æ', ' '},
{' ', '3', '\n', '-', ' ', '\'', '8', '7', '\r', '@', '4', 'Þ', ',', 'Ý', ':', '(',
 '5', '+', ')', '2', 'Ù', '6', '0', '1', '9', '?', 'Ø', ' ', '.', '/', '=', ' '}};

//---------------------------------------------------------------------------

#pragma argsused
int main(int argc, char* argv[])
{
  puts("Baudot terminal. v.1.0.\n");

  if(argc < 2)
  {
  	puts("Format: terminal.exe COMx xxx.txt");
    puts("COMx - COM port number, COM1 or COM2 or COM3 or COM4");
    puts("xxx.txt - filename of text data");
    goto exit0;
  }

  if((argc >= 2) && (argv[1][0] == 'C') && (argv[1][1] == 'O') && (argv[1][2] == 'M'))
  {
  	switch (argv[1][3])
  	{
  		case '1': baseaddr = 0x3F8; break;
  		case '2': baseaddr = 0x2F8; break;
  		case '3': baseaddr = 0x3E8; break;
  		case '4': baseaddr = 0x2E8; break;
  		default:
      {
  			puts("Wrong COM port number (COMx, x = 1, 2, 3, 4).");
  			goto exit0;
  		}
  	}

    if((pp = CreateFile(argv[1], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL)) == NULL)
  	{
  		printf("Can't open port %s.\n", argv[1]);
    	goto exit0;
  	}
  	else
  		printf("Succesfully opened port %s (%XH).\n", argv[1], baseaddr);

  	GetCommState(pp, &dcb);
    GetCommTimeouts(pp, &commtimeouts);
  	dcb.BaudRate = 50;
  	dcb.ByteSize = 5;
  	dcb.Parity = NOPARITY;
  	dcb.StopBits = ONESTOPBIT;
  	dcb.fDtrControl = DTR_CONTROL_DISABLE;
  	dcb.fRtsControl = RTS_CONTROL_DISABLE;
    commtimeouts.ReadIntervalTimeout = 1;
    commtimeouts.ReadTotalTimeoutMultiplier = 30;
    commtimeouts.ReadTotalTimeoutConstant = 30;

		if(!SetCommState(pp, &dcb))
  	{
  		printf("Can't set port %s parameters. Error: %d.\n", argv[1], GetLastError());
    	goto exit1;
  	}
  	else
  	 	printf("Succesfully set port %s parameters: 50 baud, 5 bits, 1 stop bit.\n", argv[1]);

   if(!SetCommTimeouts(pp, &commtimeouts))
  	{
  		printf("Can't set port %s timeouts. Error: %d.\n", argv[1], GetLastError());
    	goto exit1;
  	}
  	else
  	 	printf("Succesfully set port %s timeouts: 30 ms.\n", argv[1]);

  }
  else
  {
  	puts("Invalid COM port number (COMx, x = 1, 2, 3, 4).");
  	goto exit0;
  }

  if((argc > 2) && (strlen(argv[2]) > 2))
  	if((fp = CreateFile(argv[2], GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == NULL)
  	{
  		printf("Can't open file %s.\n", argv[2]);
  		goto exit1;
  	}
  	else
  	{
  		if(ReadFile(fp, buffer, FSIZE, &filesize, NULL))
  			printf("Succesfully opened file %s (%d bytes).\n", argv[2], filesize);
      else
  			goto exit2;
  	}
  else
  {
  	printf("Bad name of open file %s.\nStarting terminal (ESC - exit)...\n", argv[2]);
  	goto term;
  }

  outbuff_point = 0;
  for(i = 0; i < filesize; i++)
  {
		if ((current_case != case_table[buffer[i]]) && case_table[buffer[i]])
    {
      current_case = case_table[buffer[i]];
      if(current_case == 1)
    		outbuffer[outbuff_point] = 0xFF; //11111
      if(current_case == 2)
    		outbuffer[outbuff_point] = 0xE0; //00000
      if(current_case == 3)
    		outbuffer[outbuff_point] = 0xFB; //11011
      outbuff_point++;
    }

    outbuffer[outbuff_point] = code_table[buffer[i]];
    outbuff_point++;
  }
  puts("Translate to MTK-2... done.");

  if(WriteFile(pp, outbuffer, outbuff_point, &outbuff_point, NULL))
  	printf("Succesfully transmitted %d bytes.\n", outbuff_point);

  goto exit2;

term:
	d = 0xFF;
  WriteFile(pp, &d, 1, &outbuff_point, NULL);

	while(1)
  {
  	if(kbhit())
    {
    	c = getch();
      //printf("%d", c);
    	if(c == 0x1B)
  			goto exit1;

      if((current_case != case_table[c]) && case_table[c])
    	{
      	current_case = case_table[c];
      	if(current_case == 1)
    			d = 0xFF; //11111
      	if(current_case == 2)
    			d = 0xE0; //00000
      	if(current_case == 3)
    			d = 0xFB; //11011
      	WriteFile(pp, &d, 1, &outbuff_point, NULL);
    	}
    	d = code_table[c];
    	WriteFile(pp, &d, 1, &outbuff_point, NULL);
      if(c == 0x0D)
      {
      	d = 0x02;
    		WriteFile(pp, &d, 1, &outbuff_point, NULL);
      }
      //while(kbhit());
    }

    ReadFile(pp, &d, 1, &outbuff_point, NULL);
    if(outbuff_point)
    	switch(d)
    	{
    		case 0:
      	current_case_r = 1;
      	break;

    		case 27:
      	current_case_r = 2;
      	break;

    		case 31:
      	current_case_r = 0;
      	break;

      	default:
          printf("%c", decode_table[current_case_r][d]);
      break;
    	}
  }

  goto exit1;

exit2:
  CloseHandle(fp);
exit1:
  CloseHandle(pp);
exit0:
//	puts("\nPress any key for exit.\n");
//  getch();
  return 0;
}
//---------------------------------------------------------------------------

